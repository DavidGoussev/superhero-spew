class TokensController < ApplicationController

  def request_token
    request_token = TWITTER.get_request_token(oauth_callback: ENV['OAUTH_CALLBACK'])
    Oauth.create(token: request_token.token, secret: request_token.secret)
    redirect_to request_token.authorize_url(oauth_callback: ENV['OAUTH_CALLBACK'])
  end

# notes: obtain a request token directly from Twitter via oauth-ruby's 'get_request_token' on the callback URL as encapsulated in the development.rb & twitter dev app
# store the token & secret from twitter in db.  Then redirect user via authorize_url() method on request token obj, which generates the URL of a Twitter login page.
# after Twitter login, Twitter sends user back with ENV['oauth_callback'] URL (/access_token)

  def access_token
    oauth = Oauth.find_by(token: params[:oauth_token])
    if oauth.present?
      request_token = OAuth::RequestToken.new(TWITTER, oauth.token, oauth.secret)
      access_token = request_token.get_access_token(oauth_verifier: params[:oauth_verifier])
      user = User.find_or_create_by(uid: access_token.params[:user_id]) { |u| u.handle = access_token.params[:screen_name] }
      jwt = JWT.encode({uid: user.uid, exp: 1.day.from_now.to_i}, Rails.application.secrets.secret_key_base)
      redirect_to ENV['ORIGIN'] + "?jwt=#{jwt}"
    else
      redirect_to ENV['ORIGIN']
    end
  end
end

# this is upgrading the request token to an access_token, if request token exists.  oauth_verifier param matches up new request token generated by oauth_token param from Twitter
# if successful, we can use access token to get user_id & handle (all we need from Twitter auth)
# Then authentication for cross origin requests begins with uid gleaned from Twitter oauth that's then encoded as a JWT payload (expire 1 day), uses Rails secret key base as a JWT encode secret
# JWT payloads are signed but not encrypted so dont assign key info to payload
# Finally, user is returned to React app with a URL parameter containing JWT (that will be extracted out in React's state via App.jsx)
